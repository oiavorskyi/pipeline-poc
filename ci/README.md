# The CI/CD pipeline design and implementation

## Goals

- The pipeline shall build and unit test application artifacts whenever there is a change in the master branch of the source code repository
- It shall support automated deployment of the successfully built artifacts to the development PCF environment and their smoke testing
- The pipeline shall support deployment and smoke testing of the latest version of the artifact to the production environment with zero downtime
- Adding of the new deployment environments such as staging shall be straightforward
- The deployment artifacts shall be immutable (built once and moved between the environments without any modifications)
- The pipeline shall be as generic as possible, i.e. any specifics of the particular application shall be externalized, including configuration parameters of deployment environments, source code management system, etc.
- In addition to building and unit testing the master branch the pipeline shall support these steps for pull requests made against the source code repository. This is used to verify the correctness of the code in the pull request without producing any deployment artifacts.
- The pipeline shall enforce [semantic versioning](https://semver.org/)
- The exact version of the artifact shall be available to the application at the build time so that it could be exposed via management endpoints (e.g.  with Spring Boot Actuators)
- Developers shall be able to clone the source code repository and build snapshot version with Maven based on the current SemVer in pipeline. It shouldn't be required to make any version-related changes in the Maven pom file for it to work
- The artifacts shall be preserved both for intermediate and final builds of the particular versions (e.g. as tarball in S3)
- It shall be possible to update any component of the version used to build new artifacts
- The build version in the Maven build file shall be updated when the version is bumped
- The pipeline shall upload binary release to the GitHub repository and tag the source code with the version indication whenever it is deployed on production
- Separate storage for the build artifacts and releases

## Non goals

- Support of the VCS other than Git and GitHub
- Gradle support (for now)
- Support for air-gapped environments (for now)

## Design

The design of the pipeline is largely based on the ideas and implementation of the following projects:
- [Goulash](https://github.com/pivotalservices/goulash/tree/master/ci)
- [Spring Boot](https://github.com/spring-projects/spring-boot/tree/master/ci)
- [Spring Cloud Pipelines](https://github.com/spring-cloud/spring-cloud-pipelines)

### Resources

- `version`: SemVer resource backed by the key in S3 bucket with application releases (under `versions` folder) . Provides versions in format `MAJOR.MINOR.PATCH-rev.NUMBER`
- `source`: source code of the application from the Git repository
- `release-candidate`: S3 bucket where tarball of each potentially shippable release is stored (under `rc` folder)
- `release-final`: S3 bucket there tarball of each shipped release is stored (under `final` folder)
- `pcf-dev`: CF development space where each release candidate will be automatically deployed
- `pcf-prod`: CF development space where production release will be deployed after it has been shipped 
- `gh-release`: GitHub release configuration used to expose the new shipped release

### Jobs

#### create-rc
It builds release candidate whenever there is a change in the source code repository and publishes it to the S3 repository.

It replaces the `revision` property in a project's `pom.xml` file with the next release candidate version generated by `version` resource. Developers shall refer to this property as an build artifact version in `pom.xml`.

It uses `version` serial group so that jobs in a same group that deploy to development environment and that ship the latest release can be executed only one after another. This prevents race conditions.

#### deploy-dev
It deploys latest release candidate to the development PCF environment using the `development.yml` manifest from the release candidate tarball. It is triggered automatically whenever new version of the release candidate is produced by the `create-rc` job.

#### shipit
This manually triggered job cuts the final release out of the latest release candidate that has passed deployment to the development environment.

First it promotes the release candidate to the final release by creating copy of the tarball with updated name and publish it to the dedicated S3 bucket.

Then it updates `revision` property in `pom.xml` with the final release version (e.g 2.0.0-SNAPSHOT will become 2.0.0), commits the change and creates the tag in Git repository. Finally it changes the `revision` again to start new minor version (e.g. 2.0.0 becomes 2.1.0-SNAPSHOT), commits the change and pushes updates to the GitHub repository.

New GitHub release is created at the same tag with binary release attached to it. Then the `version` resource is updated to persist the next version number that will be used in a subsequent build.

#### deploy-prod
It deploys that latest final release to the production environment as soon as it has been shipped.

### Handling of application name conflicts during deployment

When deploying an application to a PCF environment, it is be possible that another application with the same name already exists there. It is especially likely when deploying to the public instances of PCF such as PWS.

By default the pipeline will use the parameter `application-name` to specify what application name to use for release management and deployment. However, it might be not desirable to change the name of the produced artifacts just so we could avoid a name clash during deployment. Instead, the deployment tasks in the pipeline specify suffix for the application name based on the value of property `application-deployment-suffix`. This property is empty by default (thus no suffix is added).

In addition, the `deploy-dev` job adds prefix `dev-` to the application name. This is useful not only for recognizing that the running version is development one, but also to avoid clashes in rare cases when the development and production spaces are within the same instances.